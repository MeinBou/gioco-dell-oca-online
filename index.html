<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gioco dell'Oca</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background: #a8e063;
            background: -webkit-linear-gradient(to right, #56ab2f, #a8e063);
            background: linear-gradient(to right, #56ab2f, #a8e063);
        }
        .font-fredoka {
            font-family: 'Fredoka One', cursive;
        }
        #game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
            padding: 10px;
            width: 100%;
            max-width: 1000px;
            margin: auto;
            position: relative;
        }
        .tile {
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: clamp(0.7rem, 2.5vw, 1.2rem);
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            background-size: cover;
            background-position: center;
            color: black;
        }
        .player-pawn {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            position: absolute;
            transition: all 0.1s ease-in-out;
            z-index: 10;
        }
        .player-pawn-1 { top: 5%; left: 5%; }
        .player-pawn-2 { top: 5%; right: 5%; }
        .player-pawn-3 { bottom: 5%; left: 5%; }
        .player-pawn-4 { bottom: 5%; right: 5%; }
        .player-pawn-5 { top: 27%; left: 5%; }
        .player-pawn-6 { top: 27%; right: 5%; }
        .player-pawn-7 { bottom: 27%; left: 5%; }
        .player-pawn-8 { bottom: 27%; right: 5%; }
        .player-pawn-9 { top: 5%; left: 50%; transform: translateX(-50%); }
        .player-pawn-10 { bottom: 5%; left: 50%; transform: translateX(-50%); }
        .player-pawn-11 { left: 5%; top: 50%; transform: translateY(-50%); }
        .player-pawn-12 { right: 5%; top: 50%; transform: translateY(-50%); }
        .player-pawn-13 { top: 50%; left: 25%; transform: translate(-50%, -50%); }
        .player-pawn-14 { top: 50%; right: 25%; transform: translate(50%, -50%); }


        .dice { cursor: pointer; transition: transform 0.2s ease; }
        .dice:hover { transform: scale(1.1); }
        .dice.rolling { animation: roll 0.5s infinite; }
        @keyframes roll {
            0% { transform: rotate(0deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1.1); }
        }
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); align-items: center; justify-content: center; }
        .modal-content { background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 600px; border-radius: 16px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        
        .rainbow {
            background: linear-gradient(124deg, #ff2400, #e81d1d, #e8b71d, #e3e81d, #1de840, #1ddde8, #2b1de8, #dd00f3);
            background-size: 1800% 1800%;
            animation: rainbow 18s ease infinite;
        }
        @keyframes rainbow { 0%{background-position:0% 82%} 50%{background-position:100% 19%} 100%{background-position:0% 82%} }
        
        #player-setup-container { max-height: 28vh; overflow-y: auto; padding-right: 10px; }
        
        .game-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; color: white; font-size: 1.8rem; font-weight: bold; border-radius: 15px; 
            z-index: 200; display: none; text-align: center; animation: fadeOut 3s forwards;
        }
        #elimination-message { background-color: rgba(220, 38, 38, 0.9); }
        #tile-explanation-message { background-color: rgba(30, 64, 175, 0.9); font-size: 1.5rem; }

        @keyframes fadeOut { 0%, 70% { opacity: 1; } 100% { opacity: 0; display: none;} }
        
        #eliminated-graveyard {
            position: absolute; bottom: 5px; left: 5px; background: rgba(0, 0, 0, 0.5);
            border-radius: 10px; padding: 8px; display: none; flex-wrap: wrap; gap: 5px; max-width: 40%;
        }
        .graveyard-pawn { width: 25px; height: 25px; border-radius: 50%; border: 2px solid #555; }
        
        #turn-order-container {
            border-top: 2px solid rgba(0,0,0,0.1);
            margin-top: auto;
            padding-top: 1rem;
        }
        .turn-order-pawn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid white;
            transition: all 0.3s ease;
        }
        .turn-order-pawn.current {
            border-width: 4px;
            border-color: #fbbf24; /* amber-400 */
            transform: scale(1.1);
        }

        #inventory-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            padding: 8px;
            display: none;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            z-index: 50;
        }
        .player-inventory {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.2);
            padding: 5px 10px;
            border-radius: 10px;
        }
        .inventory-pawn { width: 20px; height: 20px; border-radius: 50%; }
        .gem-slot {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #444;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
            transition: all 0.3s ease;
            filter: grayscale(1);
            opacity: 0.6;
        }
        .gem-slot.collected {
            filter: grayscale(0);
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 10px 2px #fff;
        }
        @keyframes bling { 0% { box-shadow: 0 0 0 0 rgba(255,255,100,0.7); } 50% { box-shadow: 0 0 20px 10px rgba(255,255,100,0); } 100% { box-shadow: 0 0 0 0 rgba(255,255,100,0); } }
        .gem-slot.collected.bling { animation: bling 0.7s ease-out; }

        .gem-choice-option {
            cursor: pointer;
            padding: 10px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        .gem-choice-option:hover {
            background-color: #f0f0f0;
        }

        /* Special Tile Styling */
        .tile-goose { background-image: url('https://placehold.co/100x100/AED581/FFFFFF?text=Oca'); }
        .tile-ponte { background-image: url('https://placehold.co/100x100/CD853F/FFFFFF?text=Ponte'); }
        .tile-torre { background-image: url('https://placehold.co/100x100/A1887F/FFFFFF?text=Torre'); }
        .tile-well { background-image: url('https://placehold.co/100x100/4DB6AC/FFFFFF?text=Pozzo'); }
        .tile-maze { background-image: url('https://placehold.co/100x100/F06292/FFFFFF?text=Labirinto'); }
        .tile-prison { background-image: url('https://placehold.co/100x100/757575/FFFFFF?text=Prigione'); }
        .tile-death { background-image: url('https://placehold.co/100x100/424242/FFFFFF?text=Teschio'); }
        .tile-lose-turns { background-image: url('https://placehold.co/100x100/FFB74D/FFFFFF?text=Stop'); }
        .tile-swap { background-image: url('https://placehold.co/100x100/4DD0E1/FFFFFF?text=Scambia'); }
        .tile-swap-random { background-image: url('https://placehold.co/100x100/F48FB1/FFFFFF?text=Scambia%3F'); }
        .tile-forward-3 { background-image: url('https://placehold.co/100x100/81C784/FFFFFF?text=%2B3'); }
        .tile-backward-3 { background-image: url('https://placehold.co/100x100/E57373/FFFFFF?text=-3'); }
        .tile-forward-2 { background-image: url('https://placehold.co/100x100/A5D6A7/FFFFFF?text=%2B2'); }
        .tile-backward-2 { background-image: url('https://placehold.co/100x100/EF9A9A/FFFFFF?text=-2'); }
        .tile-roll-again { background-image: url('https://placehold.co/100x100/64B5F6/FFFFFF?text=Ritira'); }
        .tile-finish { background-image: url('https://placehold.co/100x100/FFD54F/FFFFFF?text=VITTORIA'); }
        .tile-gem { font-size: 2rem; }
        .tile-gem-thief { background-image: url('https://placehold.co/100x100/8E24AA/FFFFFF?text=Ladro!'); }
        .tile-gem-swap { background-image: url('https://placehold.co/100x100/00ACC1/FFFFFF?text=Baratto'); }
        .tile-gem-choice { background-image: url('https://placehold.co/100x100/FBC02D/FFFFFF?text=Santuario'); }
    </style>
</head>
<body class="bg-green-100 text-gray-800">

    <!-- Main Menu Screen -->
    <div id="main-menu" class="min-h-screen flex flex-col items-center justify-center p-4">
        <h1 class="text-6xl md:text-8xl font-fredoka text-white text-center mb-8" style="text-shadow: 3px 3px 0 #4c9a2a;">Gioco dell'Oca</h1>
        <div class="bg-white/80 p-8 rounded-2xl shadow-xl w-full max-w-md">
            <h2 class="text-2xl font-bold text-center mb-6 text-green-700">Impostazioni di Gioco</h2>
            <div class="mb-4">
                <label for="game-mode" class="block font-bold mb-2">Modalità di Gioco:</label>
                <select id="game-mode" class="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                    <option value="classic">Classica</option>
                    <option value="elimination">Eliminazione</option>
                    <option value="gem">Oca da Collezione</option>
                    <option value="fast">Veloce (40 caselle)</option>
                    <option value="teams">Squadre</option>
                </select>
            </div>
            <div id="elimination-options" class="mb-4 hidden">
                <label for="elimination-turns" class="block font-bold mb-2">Elimina un giocatore ogni:</label>
                <select id="elimination-turns" class="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                    <option value="2">2 giri</option>
                    <option value="3">3 giri</option>
                    <option value="4">4 giri</option>
                    <option value="5">5 giri</option>
                </select>
            </div>
            <div id="gem-options" class="mb-4 hidden">
                <label for="gem-count" class="block font-bold mb-2">Obiettivo: Colleziona</label>
                <select id="gem-count" class="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500">
                    <option value="5">5 Gemme</option>
                    <option value="7">7 Gemme</option>
                    <option value="9">9 Gemme</option>
                </select>
            </div>
            <div class="mb-4">
                <label for="player-count" class="block font-bold mb-2">Numero di Giocatori:</label>
                <input type="number" id="player-count" class="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500" value="2" min="2" max="8">
            </div>
            <div id="player-setup-container" class="space-y-4"></div>
            <div class="flex gap-2 mt-6">
                <button id="online-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg text-xl transition-transform transform hover:scale-105">Online</button>
                <button id="rules-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg text-xl transition-transform transform hover:scale-105">Regole</button>
            </div>
            <button id="start-game-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-xl transition-transform transform hover:scale-105 mt-2">Gioca in Locale</button>
        </div>
    </div>
    
    <!-- Online Menu Screen -->
    <div id="online-menu" class="hidden min-h-screen flex flex-col items-center justify-center p-4">
        <div class="bg-white/80 p-8 rounded-2xl shadow-xl w-full max-w-md">
            <h2 class="text-3xl font-bold text-center mb-6 text-green-700">Modalità Online</h2>
            <button id="create-lobby-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg text-xl mb-4">Crea Lobby</button>
            <div class="border-t pt-4">
                <label for="lobby-code-input" class="block font-bold mb-2">Codice Lobby:</label>
                <input type="text" id="lobby-code-input" class="w-full p-2 border rounded-lg uppercase" placeholder="INSERISCI CODICE">
                <button id="join-lobby-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-xl mt-2">Unisciti a Lobby</button>
            </div>
             <button id="back-to-main-menu-btn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-6">Indietro</button>
        </div>
    </div>
    
    <!-- Lobby Screen -->
    <div id="lobby-screen" class="hidden min-h-screen flex flex-col items-center justify-center p-4">
         <div class="bg-white/80 p-8 rounded-2xl shadow-xl w-full max-w-2xl">
            <h2 class="text-3xl font-bold text-center mb-2 text-green-700">Lobby di Gioco</h2>
            <div class="text-center mb-4">
                <span class="font-bold">Codice Lobby:</span>
                <span id="lobby-code-display" class="text-2xl font-bold text-blue-600 bg-gray-200 px-3 py-1 rounded-lg"></span>
                <button id="copy-code-btn" class="ml-2 bg-gray-300 px-2 py-1 rounded">Copia</button>
            </div>
            <div id="lobby-player-list" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4"></div>
            <div id="host-controls" class="hidden">
                 <h3 class="text-xl font-bold mb-2">Impostazioni (Solo Host)</h3>
                 <!-- Host controls will be dynamically inserted here -->
            </div>
            <div id="player-controls">
                 <h3 class="text-xl font-bold mb-2">Il Tuo Giocatore</h3>
                 <!-- Player controls will be dynamically inserted here -->
            </div>
            <button id="start-online-game-btn" class="hidden w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-xl mt-4">Avvia Partita</button>
            <button id="leave-lobby-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg mt-2">Esci dalla Lobby</button>
        </div>
    </div>


    <!-- Game Screen -->
    <div id="game-screen" class="hidden w-full h-screen flex flex-col md:flex-row p-2 sm:p-4 gap-4 relative">
        <div id="elimination-message" class="game-message"></div>
        <div id="tile-explanation-message" class="game-message"></div>
        <div class="flex-grow flex flex-col bg-white/50 rounded-2xl p-4 shadow-lg overflow-hidden relative">
            <div id="eliminated-graveyard"></div>
            <div id="turn-indicator" class="text-center text-2xl font-fredoka text-green-800 mb-2 p-2 bg-white/70 rounded-lg"></div>
            <div id="game-board-container" class="flex-grow overflow-auto pb-24 md:pb-0">
                <div id="game-board"></div>
            </div>
            <div id="controls" class="flex flex-col sm:flex-row items-center justify-center gap-4 p-4 mt-auto">
                <div id="elimination-counter" class="hidden font-bold text-xl text-red-700 bg-white/70 px-4 py-2 rounded-lg"></div>
                <div id="dice-container" class="flex gap-4 dice">
                    <div id="dice1" class="w-16 h-16 bg-white rounded-lg flex items-center justify-center text-3xl font-bold shadow-md">?</div>
                    <div id="dice2" class="w-16 h-16 bg-white rounded-lg flex items-center justify-center text-3xl font-bold shadow-md">?</div>
                </div>
                <div class="flex items-center gap-4">
                    <button id="menu-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Menu</button>
                </div>
            </div>
        </div>
        <div id="leaderboard" class="w-full md:w-80 bg-white/50 rounded-2xl p-4 shadow-lg flex flex-col">
             <h3 class="text-2xl font-fredoka text-green-800 text-center mb-4">Classifica</h3>
             <div id="leaderboard-list" class="flex-grow space-y-2 overflow-y-auto"></div>
             <div id="turn-order-container">
                 <h4 class="text-lg font-fredoka text-green-800 text-center mb-2">Prossimi Turni</h4>
                 <div id="turn-order-indicator" class="flex justify-center items-center gap-3"></div>
             </div>
        </div>
        <div id="inventory-bar"></div>
    </div>
    
    <!-- Modals -->
    <div id="menu-modal" class="modal"><div class="modal-content text-center"><h2 class="text-2xl font-bold mb-6">Menu di Gioco</h2><button id="return-to-menu-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg mb-4">Torna al Menu Principale</button><button id="close-menu-btn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">Chiudi</button></div></div>
    <div id="confirm-modal" class="modal"><div class="modal-content text-center"><h2 id="confirm-title" class="text-xl font-bold mb-4">Sei sicuro?</h2><p id="confirm-text" class="mb-6"></p><div class="flex justify-center gap-4"><button id="confirm-yes-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg">Sì</button><button id="confirm-no-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">No</button></div></div></div>
    <div id="winner-modal" class="modal"><div class="modal-content text-center p-8"><h2 id="winner-title" class="text-4xl font-fredoka text-yellow-500 mb-4">Vincitore!</h2><p id="winner-text" class="text-xl mb-6"></p><button id="play-again-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-lg">Gioca Ancora</button></div></div>
    <div id="rules-modal" class="modal"><div id="rules-content" class="modal-content"><h2 class="text-2xl font-bold mb-4 text-center">Regole del Gioco</h2><div id="classic-rules"></div><div id="gem-rules" class="hidden"></div><button id="close-rules-btn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-6">Chiudi</button></div></div>
    <div id="podium-modal" class="modal"><div class="modal-content"><h2 class="text-4xl font-fredoka text-center mb-6 text-gray-700">Classifica Finale</h2><div id="podium-container" class="flex items-end justify-center gap-2 h-64"><div id="podium-2" class="podium-stand flex flex-col items-center justify-end p-4 bg-gray-400 w-1/4 h-2/3 rounded-t-lg order-1"><div id="pawn-2" class="w-12 h-12 rounded-full border-4 border-white mb-2"></div><h3 id="name-2" class="font-bold text-white text-lg truncate w-full text-center"></h3><div class="text-4xl font-bold text-white">2</div></div><div id="podium-1" class="podium-stand flex flex-col items-center justify-end p-4 bg-yellow-500 w-1/3 h-full rounded-t-lg order-2"><div id="pawn-1" class="w-16 h-16 rounded-full border-4 border-white mb-2"></div><h3 id="name-1" class="font-bold text-white text-xl truncate w-full text-center"></h3><div class="text-5xl font-bold text-white">1</div></div><div id="podium-3" class="podium-stand flex flex-col items-center justify-end p-4 bg-orange-600 w-1/4 h-1/2 rounded-t-lg order-3"><div id="pawn-3" class="w-10 h-10 rounded-full border-4 border-white mb-2"></div><h3 id="name-3" class="font-bold text-white text-base truncate w-full text-center"></h3><div class="text-3xl font-bold text-white">3</div></div></div><button id="podium-play-again-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-lg mt-8">Gioca Ancora</button></div></div>
    <div id="gem-choice-modal" class="modal"><div class="modal-content"><h2 class="text-2xl font-bold mb-4 text-center">Santuario delle Gemme</h2><p class="text-center mb-4">Scegli una gemma da collezionare.</p><div id="gem-choice-options" class="flex flex-wrap justify-center gap-4"></div></div></div>

    <script type="module">
        // Importa le funzioni necessarie da Firebase SDK
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, collection, deleteDoc, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Globals
        let db, auth;

        // App State Globals
        let state = {};
        let isOnlineGame = false;
        let currentLobbyId = null;
        let lobbyUnsubscribe = null;
        let localPlayerAnimationTimeout = null;

        const colors = { red: "Rosso", pink: "Rosa", blue: "Blu", yellow: "Giallo", orange: "Arancione", lime: "Lime", darkgreen: "Verde Scuro", purple: "Viola", cyan: "Ciano", silver: "Argento", gold: "Oro", rainbow: "Arcobaleno", white: "Bianco", black: "Nero", "maroon": "Bordeaux", "navy": "Blu Scuro" };
        const colorKeys = Object.keys(colors);
        const colorClasses = { red: 'bg-red-500', pink: 'bg-pink-400', blue: 'bg-blue-500', yellow: 'bg-yellow-400', orange: 'bg-orange-500', lime: 'bg-lime-400', darkgreen: 'bg-green-700', purple: 'bg-purple-600', cyan: 'bg-cyan-500', silver: 'bg-gray-400', gold: 'bg-yellow-500', rainbow: 'rainbow', white: 'bg-white', black: 'bg-black', maroon: 'bg-red-800', navy: 'bg-blue-800' };
        const defaultNames = { red: "Reddy", pink: "Piper", blue: "Blue", yellow: "Jared", orange: "Oran", lime: "Lime", darkgreen: "Vector", purple: "Belle", cyan: "Penny", silver: "Silver", gold: "Goldy", rainbow: "Rain", white: "Ted", black: "Blacky", maroon: "Malik", navy: "Dan"};
        const gemData = { ruby: { id: 'ruby', name: "Rubino", icon: "🔴" }, emerald: { id: 'emerald', name: "Smeraldo", icon: "🟢" }, sapphire: { id: 'sapphire', name: "Zaffiro", icon: "🔵" }, amethyst: { id: 'amethyst', name: "Ametista", icon: "🟣" }, diamond: { id: 'diamond', name: "Diamante", icon: "⚪️" }, topaz: { id: 'topaz', name: "Topazio", icon: "🟡" }, onyx: { id: 'onyx', name: "Onice", icon: "⚫️" }, citrine: { id: 'citrine', name: "Citrino", icon: "🟠" }, garnet: { id: 'garnet', name: "Granato", icon: "🟤" } };
        const gemList = Object.values(gemData);

        // --- INITIALIZATION ---
        
        async function initializeFirebase() {
            const userProvidedConfig = {
    apiKey: "AIzaSyCylKpsbhvkOppxJoInXrP81gC2DOqq2Ao",
    authDomain: "total-drama-judge.firebaseapp.com",
    projectId: "total-drama-judge",
    storageBucket: "total-drama-judge.firebasestorage.app",
    messagingSenderId: "807046352867",
    appId: "1:807046352867:web:a1c1849ad7b3cd19481ad6",
    measurementId: "G-0BR32MRK92"
};

            const firebaseConfig = typeof __firebase_config !== 'undefined' 
                ? JSON.parse(__firebase_config) 
                : userProvidedConfig;

            if (!firebaseConfig.apiKey || firebaseConfig.apiKey.includes("...")) {
                 document.body.innerHTML = `<div class="text-red-500 text-center p-8 text-xl bg-white rounded-lg shadow-md m-4">
                    <h2 class="font-bold text-2xl mb-4">Errore di Configurazione</h2>
                    <p>La configurazione di Firebase non è valida o non è stata trovata.</p>
                    <p class="mt-2 text-base text-gray-600">Se stai eseguendo questo gioco al di fuori dell'ambiente di sviluppo originale (come su GitHub), devi incollare le tue credenziali Firebase nel file <code>index.html</code>.</p>
                 </div>`;
                 console.error("Configurazione Firebase non valida o mancante.");
                 return false;
            }

            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
                document.body.innerHTML = `<div class="text-red-500 text-center p-8">Authentication Failed. Please refresh. Error: ${error.message}</div>`;
                return false;
            }
            return true;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const isAuthReady = await initializeFirebase();
            if (isAuthReady) {
                runAppLogic();
            }
        });

    function runAppLogic() {
        const mainMenu = document.getElementById('main-menu'), gameScreen = document.getElementById('game-screen'), gameModeSelect = document.getElementById('game-mode'), eliminationOptions = document.getElementById('elimination-options'), gemOptions = document.getElementById('gem-options'), playerCountInput = document.getElementById('player-count'), playerSetupContainer = document.getElementById('player-setup-container'), startGameBtn = document.getElementById('start-game-btn'), rulesBtn = document.getElementById('rules-btn'), gameBoard = document.getElementById('game-board'), turnIndicator = document.getElementById('turn-indicator'), leaderboardList = document.getElementById('leaderboard-list'), diceContainer = document.getElementById('dice-container'), dice1El = document.getElementById('dice1'), dice2El = document.getElementById('dice2'), menuButton = document.getElementById('menu-button'), menuModal = document.getElementById('menu-modal'), closeMenuBtn = document.getElementById('close-menu-btn'), returnToMenuBtn = document.getElementById('return-to-menu-btn'), confirmModal = document.getElementById('confirm-modal'), confirmYesBtn = document.getElementById('confirm-yes-btn'), confirmNoBtn = document.getElementById('confirm-no-btn'), winnerModal = document.getElementById('winner-modal'), podiumModal = document.getElementById('podium-modal'), podiumPlayAgainBtn = document.getElementById('podium-play-again-btn'), playAgainBtn = document.getElementById('play-again-btn'), rulesModal = document.getElementById('rules-modal'), closeRulesBtn = document.getElementById('close-rules-btn'), eliminationCounterEl = document.getElementById('elimination-counter'), eliminationMessageEl = document.getElementById('elimination-message'), tileExplanationEl = document.getElementById('tile-explanation-message'), graveyardEl = document.getElementById('eliminated-graveyard'), turnOrderIndicator = document.getElementById('turn-order-indicator'), inventoryBar = document.getElementById('inventory-bar'), gemChoiceModal = document.getElementById('gem-choice-modal'), gemChoiceOptions = document.getElementById('gem-choice-options'), classicRulesEl = document.getElementById('classic-rules'), gemRulesEl = document.getElementById('gem-rules');
        const onlineBtn = document.getElementById('online-btn'), onlineMenu = document.getElementById('online-menu'), backToMainMenuBtn = document.getElementById('back-to-main-menu-btn'), createLobbyBtn = document.getElementById('create-lobby-btn'), joinLobbyBtn = document.getElementById('join-lobby-btn'), lobbyCodeInput = document.getElementById('lobby-code-input'), lobbyScreen = document.getElementById('lobby-screen'), lobbyCodeDisplay = document.getElementById('lobby-code-display'), copyCodeBtn = document.getElementById('copy-code-btn'), lobbyPlayerList = document.getElementById('lobby-player-list'), hostControls = document.getElementById('host-controls'), playerControls = document.getElementById('player-controls'), startOnlineGameBtn = document.getElementById('start-online-game-btn'), leaveLobbyBtn = document.getElementById('leave-lobby-btn');
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-goose-game';
        
        function initializeState() { state = { players: [], gameMode: 'classic', eliminationTurns: 3, gemsToCollect: 5, totalTiles: 80, currentPlayerIndex: 0, gameRounds: 0, isGameOver: false, isMoving: false, specialTiles: {}, gemLocations: {}, status: 'waiting', hostId: null, lastRoll: null, diceResult: [0,0] }; }

        function setupPlayerInputs() {
            const count = parseInt(playerCountInput.value);
            playerSetupContainer.innerHTML = '';
            for (let i = 0; i < count; i++) {
                const defaultColor = colorKeys[i % colorKeys.length];
                const defaultName = defaultNames[defaultColor];
                const teamSelectHTML = state.gameMode === 'teams' ? `<select class="player-team w-full p-2 border rounded-lg mt-2"><option value="1">Squadra 1</option><option value="2">Squadra 2</option>${count > 4 ? '<option value="3">Squadra 3</option>' : ''}${count > 6 ? '<option value="4">Squadra 4</option>' : ''}</select>` : '';
                playerSetupContainer.innerHTML += `<div class="p-4 bg-gray-100 rounded-lg"><h4 class="font-bold text-lg mb-2">Giocatore ${i + 1}</h4><div class="grid grid-cols-2 gap-4"><input type="text" id="player-name-${i}" class="player-name p-2 border rounded-lg" placeholder="Inserisci Nome" value="${defaultName}"><select id="player-color-${i}" class="player-color p-2 border rounded-lg">${colorKeys.map(c => `<option value="${c}" ${c === defaultColor ? 'selected' : ''}>${colors[c]}</option>`).join('')}</select><select class="player-type p-2 border rounded-lg col-span-2"><option value="human" ${i === 0 ? 'selected' : ''}>Umano</option><option value="cpu" ${i > 0 ? 'selected' : ''}>CPU</option></select>${teamSelectHTML}</div></div>`;
            }
            for (let i = 0; i < count; i++) {
                const colorSelect = document.getElementById(`player-color-${i}`);
                const nameInput = document.getElementById(`player-name-${i}`);
                colorSelect.addEventListener('change', (event) => {
                    const newColor = event.target.value;
                    nameInput.value = defaultNames[newColor] || `Giocatore ${i + 1}`;
                });
            }
        }
        
        gameModeSelect.addEventListener('change', (e) => {
            state.gameMode = e.target.value;
            eliminationOptions.classList.toggle('hidden', state.gameMode !== 'elimination');
            gemOptions.classList.toggle('hidden', state.gameMode !== 'gem');
            if (state.gameMode === 'elimination') { playerCountInput.max = 14; }
            else if (state.gameMode === 'gem') { playerCountInput.max = 10; } 
            else { playerCountInput.max = 8; }
            if (parseInt(playerCountInput.value) > playerCountInput.max) { playerCountInput.value = playerCountInput.max; }
            setupPlayerInputs();
        });

        playerCountInput.addEventListener('input', setupPlayerInputs);
        initializeState();
        setupPlayerInputs();
        setupRulesModals();

        startGameBtn.addEventListener('click', () => {
            isOnlineGame = false;
            initializeState();
            state.gameMode = gameModeSelect.value;
            state.eliminationTurns = parseInt(document.getElementById('elimination-turns').value);
            state.gemsToCollect = parseInt(document.getElementById('gem-count').value);
            state.totalTiles = (state.gameMode === 'fast') ? 40 : 80;
            const nameInputs = document.querySelectorAll('.player-name'), colorInputs = document.querySelectorAll('.player-color'), typeInputs = document.querySelectorAll('.player-type'), teamInputs = document.querySelectorAll('.player-team');
            for (let i = 0; i < playerCountInput.value; i++) { state.players.push({ id: i, name: nameInputs[i].value || `Giocatore ${i + 1}`, color: colorInputs[i].value, type: typeInputs[i].value, position: 1, lap: 1, skippedTurns: 0, isEliminated: false, team: state.gameMode === 'teams' ? teamInputs[i].value : null, gems: [] }); }
            
            showGameScreen();
            if (currentPlayer().type === 'cpu') setTimeout(playTurn, 1000);
        });

        onlineBtn.addEventListener('click', () => {
            mainMenu.classList.add('hidden');
            onlineMenu.classList.remove('hidden');
        });

        backToMainMenuBtn.addEventListener('click', () => {
            onlineMenu.classList.add('hidden');
            mainMenu.classList.remove('hidden');
        });

        createLobbyBtn.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user) { return; }

            const lobbyId = generateLobbyCode();
            currentLobbyId = lobbyId;
            isOnlineGame = true;
            
            initializeState();
            state.hostId = user.uid;
            state.gameMode = gameModeSelect.value;
            state.eliminationTurns = parseInt(document.getElementById('elimination-turns').value);
            state.gemsToCollect = parseInt(document.getElementById('gem-count').value);
            state.totalTiles = (state.gameMode === 'fast') ? 40 : 80;
            
            const hostPlayer = {
                uid: user.uid, id: 0, name: defaultNames[colorKeys[0]], color: colorKeys[0], type: 'human',
                position: 1, lap: 1, skippedTurns: 0, isEliminated: false, team: null, gems: []
            };
            state.players.push(hostPlayer);

            const lobbyRef = doc(db, `artifacts/${appId}/public/data/lobbies/${lobbyId}`);
            try {
                await setDoc(lobbyRef, state);
                listenToLobby(lobbyId);
                onlineMenu.classList.add('hidden');
                lobbyScreen.classList.remove('hidden');
            } catch (error) {
                console.error("Errore nella creazione della lobby:", error);
                alert("Impossibile creare la lobby: " + error.message);
            }
        });

        joinLobbyBtn.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user) { return; }
            const lobbyId = lobbyCodeInput.value.toUpperCase();
            if (!lobbyId) { alert("Inserisci un codice lobby."); return; }

            const lobbyRef = doc(db, `artifacts/${appId}/public/data/lobbies/${lobbyId}`);
            try {
                await runTransaction(db, async (transaction) => {
                    const lobbyDoc = await transaction.get(lobbyRef);
                    if (!lobbyDoc.exists()) { throw "Lobby non trovata!"; }
                    
                    const lobbyData = lobbyDoc.data();
                    if (lobbyData.status !== 'waiting') { throw "La partita è già iniziata o terminata."; }

                    if (!lobbyData.players.some(p => p.uid === user.uid)) {
                        const newPlayerId = lobbyData.players.length;
                        const defaultColor = colorKeys[newPlayerId % colorKeys.length];
                        const newPlayer = {
                            uid: user.uid, id: newPlayerId, name: defaultNames[defaultColor], color: defaultColor, type: 'human',
                            position: 1, lap: 1, skippedTurns: 0, isEliminated: false, team: null, gems: []
                        };
                        lobbyData.players.push(newPlayer);
                        transaction.update(lobbyRef, { players: lobbyData.players });
                    }
                });

                currentLobbyId = lobbyId;
                isOnlineGame = true;
                listenToLobby(lobbyId);
                onlineMenu.classList.add('hidden');
                lobbyScreen.classList.remove('hidden');

            } catch (error) {
                console.error("Errore nell'unirsi alla lobby:", error);
                alert("Impossibile unirsi alla lobby: " + error);
            }
        });

        leaveLobbyBtn.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user || !currentLobbyId) return;

            if (lobbyUnsubscribe) lobbyUnsubscribe();

            const lobbyRef = doc(db, `artifacts/${appId}/public/data/lobbies/${currentLobbyId}`);
            try {
                 await runTransaction(db, async (transaction) => {
                    const lobbyDoc = await transaction.get(lobbyRef);
                    if (!lobbyDoc.exists()) return;
                    let lobbyData = lobbyDoc.data();
                    if (lobbyData.hostId === user.uid) {
                        transaction.delete(lobbyRef);
                    } else { 
                        const updatedPlayers = lobbyData.players.filter(p => p.uid !== user.uid);
                        transaction.update(lobbyRef, { players: updatedPlayers });
                    }
                });
            } catch (error) { console.error("Error leaving lobby:", error); }
            
            resetToMainMenu();
        });

        startOnlineGameBtn.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (!user || !currentLobbyId || state.hostId !== user.uid) return;
            
            const cpuCount = parseInt(document.getElementById('online-cpu-count')?.value || 0);
            for (let i = 0; i < cpuCount; i++) {
                const newPlayerId = state.players.length;
                const defaultColor = colorKeys[newPlayerId % colorKeys.length];
                const cpuPlayer = {
                    uid: `cpu-${newPlayerId}-${Date.now()}`, id: newPlayerId, name: `CPU ${i + 1}`, color: defaultColor, type: 'cpu',
                    position: 1, lap: 1, skippedTurns: 0, isEliminated: false, team: null, gems: []
                };
                state.players.push(cpuPlayer);
            }

            state.status = 'in-progress';
            const lobbyRef = doc(db, `artifacts/${appId}/public/data/lobbies/${currentLobbyId}`);
            await updateDoc(lobbyRef, { status: 'in-progress', players: state.players });
        });

        async function handleHostLogic(newState) {
            const isHost = auth.currentUser && auth.currentUser.uid === newState.hostId;
            if (!isHost) return;

            const player = newState.players[newState.currentPlayerIndex];
            if (newState.lastRoll && newState.lastRoll.uid === player.uid) {
                const { d1, d2 } = newState.lastRoll;
                await handleMoveSequence(player, d1 + d2, false);
            }
            else if (player.type === 'cpu' && !newState.isMoving && newState.status === 'in-progress') {
                await playTurn();
            }
        }
        
        function listenToLobby(lobbyId) {
            const lobbyRef = doc(db, `artifacts/${appId}/public/data/lobbies/${lobbyId}`);
            let isFirstSnapshot = true;
            lobbyUnsubscribe = onSnapshot(lobbyRef, (doc) => {
                if (!doc.exists()) {
                    alert("La lobby è stata chiusa dall'host.");
                    if (lobbyUnsubscribe) lobbyUnsubscribe();
                    resetToMainMenu();
                    return;
                }

                const oldState = state;
                state = doc.data(); 
                
                if (state.status === 'waiting') {
                    renderLobbyScreen();
                } else if (state.status === 'in-progress' || state.status === 'finished') {
                    if (isFirstSnapshot) {
                        lobbyScreen.classList.add('hidden');
                        showGameScreen();
                        isFirstSnapshot = false;
                    }
                    updateGameUI(oldState, state);
                    if (state.isGameOver) {
                         showPodium();
                    }
                }
                handleHostLogic(state);
            });
        }

        function updateGameUI(oldState, newState) {
            if (JSON.stringify(oldState.players) !== JSON.stringify(newState.players)) {
                clearTimeout(localPlayerAnimationTimeout);
                animatePlayerMoves(oldState.players, newState.players);
                updateLeaderboard();
                if (state.gameMode === 'gem') updateInventoryBar();
            }
            if (oldState.currentPlayerIndex !== newState.currentPlayerIndex || oldState.isMoving !== newState.isMoving) {
                updateTurnIndicator();
                updateTurnOrderIndicator();
            }
            if(newState.diceResult[0] !== 0) {
                dice1El.textContent = newState.diceResult[0];
                dice2El.textContent = newState.diceResult[1];
            }
        }

        async function animatePlayerMoves(oldPlayers, newPlayers) {
            const moves = [];
            for(const newPlayer of newPlayers) {
                const oldPlayer = oldPlayers.find(p => p.id === newPlayer.id);
                if (oldPlayer && oldPlayer.position !== newPlayer.position) {
                    moves.push({ player: newPlayer, from: oldPlayer.position, to: newPlayer.position });
                }
            }
            
            renderPlayersOnBoard(); // Initially render at the final position
            
            for(const move of moves) {
                const pawnEl = document.getElementById(`pawn-${move.player.id}`);
                if (!pawnEl) continue;
                
                const path = [];
                const direction = move.to > move.from ? 1 : -1;
                if (Math.abs(move.to - move.from) > state.totalTiles / 2) { // Lap change
                    for(let i = move.from; i !== move.to + direction; i += direction) {
                         let pos = i;
                         if (pos > state.totalTiles) pos = 1;
                         if (pos < 1) pos = state.totalTiles;
                         path.push(pos);
                         if (pos === move.to) break;
                    }
                } else {
                    for(let i = move.from; i !== move.to + direction; i += direction) {
                        path.push(i);
                    }
                }

                for (const pos of path) {
                    const tileEl = document.getElementById(`tile-${pos}`);
                    if(tileEl) tileEl.appendChild(pawnEl);
                    await sleep(100);
                }
            }
        }


        function renderLobbyScreen() {
            const user = auth.currentUser;
            if (!user) return;
            
            lobbyCodeDisplay.textContent = currentLobbyId;
            
            lobbyPlayerList.innerHTML = '';
            state.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'p-4 bg-gray-200 rounded-lg flex items-center gap-4';
                playerCard.innerHTML = `<div class="w-8 h-8 rounded-full ${colorClasses[player.color]}"></div><div class="font-bold flex-grow">${player.name} ${player.uid === state.hostId ? '(Host)' : ''}</div>`;
                lobbyPlayerList.appendChild(playerCard);
            });

            const isHost = user.uid === state.hostId;
            hostControls.classList.toggle('hidden', !isHost);
            startOnlineGameBtn.classList.toggle('hidden', !isHost);
            
            if (isHost) {
                hostControls.innerHTML = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div><label for="online-game-mode" class="block font-bold mb-1">Modalità:</label><select id="online-game-mode" class="w-full p-2 border rounded-lg">${gameModeSelect.innerHTML}</select></div>
                        <div><label for="online-cpu-count" class="block font-bold mb-1">Giocatori CPU:</label><input type="number" id="online-cpu-count" class="w-full p-2 border rounded-lg" value="0" min="0" max="6"></div>
                    </div>`;
                document.getElementById('online-game-mode').value = state.gameMode;
                document.getElementById('online-game-mode').addEventListener('change', (e) => updateLobbySettings({ gameMode: e.target.value }));
            }

            const self = state.players.find(p => p.uid === user.uid);
            if (self) {
                playerControls.innerHTML = `
                <div class="grid grid-cols-2 gap-4 p-4 bg-blue-100 rounded-lg">
                    <input type="text" id="online-player-name" class="p-2 border rounded-lg" value="${self.name}">
                    <select id="online-player-color" class="p-2 border rounded-lg">${colorKeys.map(c => `<option value="${c}" ${c === self.color ? 'selected' : ''}>${colors[c]}</option>`).join('')}</select>
                </div>`;
                document.getElementById('online-player-name').addEventListener('change', (e) => updateSelfInLobby({ name: e.target.value }));
                document.getElementById('online-player-color').addEventListener('change', (e) => updateSelfInLobby({ color: e.target.value }));
            }
        }

        async function updateLobbySettings(settings) {
            if (!currentLobbyId) return;
            const lobbyRef = doc(db, `artifacts/${appId}/public/data/lobbies/${currentLobbyId}`);
            await updateDoc(lobbyRef, settings);
        }

        async function updateSelfInLobby(data) {
             const user = auth.currentUser;
            if (!user || !currentLobbyId) return;

            const lobbyRef = doc(db, `artifacts/${appId}/public/data/lobbies/${currentLobbyId}`);
             try {
                 await runTransaction(db, async (transaction) => {
                    const lobbyDoc = await transaction.get(lobbyRef);
                    if (!lobbyDoc.exists()) throw "Lobby non trovata.";
                    
                    const lobbyData = lobbyDoc.data();
                    const playerIndex = lobbyData.players.findIndex(p => p.uid === user.uid);
                    if (playerIndex > -1) {
                        Object.assign(lobbyData.players[playerIndex], data);
                        transaction.update(lobbyRef, { players: lobbyData.players });
                    }
                });
            } catch(error) { console.error("Failed to update player:", error); }
        }
        
        function generateLobbyCode() { return Math.random().toString(36).substring(2, 8).toUpperCase(); }

        function resetToMainMenu() {
            if (lobbyUnsubscribe) lobbyUnsubscribe();
            lobbyUnsubscribe = null;
            currentLobbyId = null;
            isOnlineGame = false;
            location.reload(); 
        }

        function showGameScreen() {
            if (state.gameMode === 'elimination') { eliminationCounterEl.classList.remove('hidden'); graveyardEl.style.display = 'flex'; updateEliminationCounter(); }
            if (state.gameMode === 'gem') { inventoryBar.style.display = 'flex'; createInventoryBar(); updateInventoryBar(); }
            mainMenu.classList.add('hidden'); gameScreen.classList.remove('hidden'); gameScreen.classList.add('flex');
            createGameBoard(); renderPlayersOnBoard(); updateLeaderboard(); updateTurnIndicator(); updateTurnOrderIndicator();
        }

        function createGameBoard() {
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${state.totalTiles === 40 ? 8 : 10}, 1fr)`;
            
            if (!state.specialTiles || Object.keys(state.specialTiles).length === 0) {
                 defineSpecialTiles();
                 if(isOnlineGame && auth.currentUser.uid === state.hostId) {
                     updateLobbySettings({ specialTiles: state.specialTiles, gemLocations: state.gemLocations });
                 }
            }

            for (let i = 1; i <= state.totalTiles; i++) {
                const tile = document.createElement('div');
                tile.id = `tile-${i}`;
                tile.className = 'tile';
                const special = state.specialTiles[i];
                if (special) {
                    if (special.type === 'gem') { tile.innerHTML = special.gem.icon; tile.classList.add('tile-gem'); } 
                    else { tile.classList.add(`tile-${special.type.replace(/ /g, '-').toLowerCase()}`); }
                } else { tile.textContent = i; }
                gameBoard.appendChild(tile);
            }
        }
        
        function defineSpecialTiles() {
            state.specialTiles = {}; state.gemLocations = {};
            const max = state.totalTiles;
            let forbiddenTiles = [1, max]; 
            let masterPool = [];

            if (state.gameMode === 'gem') {
                const gemsForThisGame = gemList.slice(0, state.gemsToCollect);
                for(let i=2; i<max; i++) masterPool.push(i);
                for (let i = masterPool.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [masterPool[i], masterPool[j]] = [masterPool[j], masterPool[i]]; }
                gemsForThisGame.forEach(gem => {
                    for(let i = 0; i < 2; i++) { 
                        const tileNum = masterPool.pop();
                        state.specialTiles[tileNum] = { type: 'gem', gem: gem };
                        if (!state.gemLocations[gem.id]) { state.gemLocations[gem.id] = tileNum; }
                    }
                });
                state.specialTiles[masterPool.pop()] = { type: 'gem-thief' };
                state.specialTiles[masterPool.pop()] = { type: 'gem-swap' };
                state.specialTiles[masterPool.pop()] = { type: 'gem-choice' };
            } else {
                state.specialTiles[6] = { type: 'ponte' }; state.specialTiles[8] = { type: 'torre' };
                forbiddenTiles.push(6, 8, 12, 22, 39);
                for (let i = 2; i < max; i++) { if (!forbiddenTiles.includes(i)) { masterPool.push(i); } }
                const tileCounts = { 'goose': 9, 'prison': 4, 'lose turns': 5, 'swap': 2, 'swap random': 2, 'forward 3': 5, 'forward 2': 2 };
                if (state.gameMode !== 'elimination') { tileCounts['well'] = 2; }
                let mazePool = masterPool.filter(t => t >= 50 && t <= 60);
                for (let i = 0; i < 2; i++) { if (mazePool.length === 0) break; const mazeIndex = Math.floor(Math.random() * mazePool.length); const tileNum = mazePool.splice(mazeIndex, 1)[0]; state.specialTiles[tileNum] = { type: 'maze' }; masterPool = masterPool.filter(t => t !== tileNum); }
                const placeConstrained = (type, count, minPos) => { let pool = masterPool.filter(t => t >= minPos); for (let i = 0; i < count; i++) { if (pool.length === 0) break; const index = Math.floor(Math.random() * pool.length); const tileNum = pool.splice(index, 1)[0]; state.specialTiles[tileNum] = { type: type }; masterPool = masterPool.filter(t => t !== tileNum); } };
                placeConstrained('death', 3, 11); placeConstrained('backward 3', 5, 5); placeConstrained('backward 2', 2, 3);
                for (const type in tileCounts) { for (let i = 0; i < tileCounts[type]; i++) { if (masterPool.length === 0) break; const index = Math.floor(Math.random() * masterPool.length); const tileNum = masterPool.splice(index, 1)[0]; state.specialTiles[tileNum] = { type }; } }
            }
            if (state.gameMode !== 'elimination') { state.specialTiles[max] = { type: 'finish' }; }
        }

        function renderPlayersOnBoard() {
            document.querySelectorAll('.player-pawn').forEach(p => p.remove());
            state.players.forEach(player => {
                if (player.isEliminated) return;
                const pawn = document.createElement('div');
                pawn.id = `pawn-${player.id}`;
                pawn.className = `player-pawn player-pawn-${(player.id % 14) + 1} ${colorClasses[player.color]}`;
                pawn.title = player.name;
                const tileEl = document.getElementById(`tile-${player.position}`);
                if (tileEl) tileEl.appendChild(pawn);
            });
        }

        function updateLeaderboard() {
            let sortedPlayers = [...state.players].sort((a, b) => { if(a.isEliminated && !b.isEliminated) return 1; if(!a.isEliminated && b.isEliminated) return -1; return (b.lap - a.lap) || (b.position - a.position); });
            leaderboardList.innerHTML = '';
            sortedPlayers.forEach((player, index) => {
                let rankColor = ''; const rank = index + 1;
                if (!player.isEliminated) { if (rank === 1) rankColor = 'text-yellow-500'; else if (rank === 2) rankColor = 'text-gray-500'; else if (rank === 3) rankColor = 'text-orange-600'; }
                const eliminatedClass = player.isEliminated ? 'opacity-60 bg-red-200/50' : 'bg-white/70';
                const teamInfo = player.team ? ` (S${player.team})` : '';
                let positionText = player.isEliminated ? 'Fuori' : player.position;
                if(state.gameMode === 'elimination' && !player.isEliminated) { positionText = `G${player.lap} - ${player.position}`; }
                leaderboardList.innerHTML += `<div class="flex items-center p-2 rounded-lg ${eliminatedClass}"><div class="font-bold text-lg w-8 ${rankColor}">${player.isEliminated ? '❌' : rank}</div><div class="w-6 h-6 rounded-full ${colorClasses[player.color]} mr-3 border-2 border-white shrink-0"></div><div class="flex-grow font-bold truncate pr-2">${player.name}${teamInfo}</div><div class="font-bold text-lg whitespace-nowrap">${positionText}</div></div>`;
            });
        }
        
        function updateTurnIndicator() {
            if (state.isGameOver) return;
            const player = currentPlayer();
            if (!player) return;

            turnIndicator.textContent = `È il turno di ${player.name}!`;
            const playerColorClass = colorClasses[player.color] || 'bg-gray-500';
            turnIndicator.className = `text-center text-2xl font-fredoka text-white mb-2 p-2 rounded-lg ${playerColorClass}`;
            
            let canPlay = false;
            if (isOnlineGame) {
                 const user = auth.currentUser;
                 canPlay = user && user.uid === player.uid && player.type === 'human';
            } else {
                 canPlay = player.type === 'human';
            }

            diceContainer.classList.toggle('pointer-events-none', !canPlay || state.isMoving);
            diceContainer.classList.toggle('opacity-50', !canPlay || state.isMoving);
        }
        
        function currentPlayer() { return state.players[state.currentPlayerIndex]; }
        
        function updateEliminationCounter() {
            if (state.gameMode !== 'elimination' || state.isGameOver) return;
            const roundsLeft = state.eliminationTurns - (state.gameRounds % state.eliminationTurns);
            eliminationCounterEl.textContent = `Eliminazione tra ${roundsLeft} giri`;
        }
        
        function updateTurnOrderIndicator() {
            turnOrderIndicator.innerHTML = '';
            const activePlayers = state.players.filter(p => !p.isEliminated);
            if (activePlayers.length < 2) return;
            const player = currentPlayer();
            if (!player) return;
            const currentIdx = activePlayers.findIndex(p => p.id === player.id);
            if (currentIdx === -1) return;

            for (let i = 0; i < Math.min(activePlayers.length, 5); i++) {
                const playerToShow = activePlayers[(currentIdx + i) % activePlayers.length];
                const pawn = document.createElement('div');
                pawn.className = `turn-order-pawn ${colorClasses[playerToShow.color]}`;
                if (i === 0) pawn.classList.add('current');
                pawn.title = playerToShow.name;
                turnOrderIndicator.appendChild(pawn);
            }
        }

        function createInventoryBar() {
            inventoryBar.innerHTML = '';
            state.players.forEach(player => {
                const inventoryDiv = document.createElement('div');
                inventoryDiv.id = `inventory-${player.id}`;
                inventoryDiv.className = 'player-inventory';
                const pawn = `<div class="inventory-pawn ${colorClasses[player.color]}"></div>`;
                const name = `<div class="text-white font-bold text-sm">${player.name}</div>`;
                let gemsHTML = '';
                const gemsForThisGame = gemList.slice(0, state.gemsToCollect);
                gemsForThisGame.forEach(gem => { gemsHTML += `<div id="gem-${player.id}-${gem.id}" class="gem-slot" title="${gem.name}">${gem.icon}</div>`; });
                inventoryDiv.innerHTML = `${pawn}${name}<div class="flex gap-1">${gemsHTML}</div>`;
                inventoryBar.appendChild(inventoryDiv);
            });
        }

        function updateInventoryBar() {
            state.players.forEach(player => {
                const gemsForThisGame = gemList.slice(0, state.gemsToCollect);
                gemsForThisGame.forEach(gem => {
                    const slot = document.getElementById(`gem-${player.id}-${gem.id}`);
                    if (slot) { slot.classList.toggle('collected', player.gems.includes(gem.id)); }
                });
            });
        }

        function showTileExplanation(type, extraInfo = '') {
            const explanations = {
                'goose': "Oca! Avanzi ancora!", 'ponte': "Ponte! Vai alla casella 12!", 'torre': "Torre! Sali alla casella 22!",
                'well': "Sei caduto nel Pozzo! Fermo.", 'maze': "Labirinto! Torna alla casella 39.", 'prison': "In Prigione! Salta i prossimi turni.",
                'death': "Teschio! Torna indietro di 10 caselle.", 'lose turns': "Stop! Salta il prossimo turno.", 'swap': "Scambio! Prendi il posto del primo.",
                'swap random': "Scambio a Sorpresa!", 'forward 3': "Avanti di 3 caselle!", 'backward 3': "Indietro di 3 caselle!",
                'forward 2': "Avanti di 2 caselle!", 'backward 2': "Indietro di 2 caselle!", 'roll again': "Fortuna! Lancia di nuovo i dadi.",
                'gem': `Gemma ${extraInfo} raccolta!`, 'gem-thief': `Ladro di gemme! Hai perso una gemma!`, 'gem-swap': `Baratto! Hai scambiato una gemma.`,
                'gem-choice': `Santuario! Scegli una gemma!`
            };
            const text = explanations[type];
            if (!text) return;
            tileExplanationEl.textContent = text;
            tileExplanationEl.style.display = 'block';
            setTimeout(() => { tileExplanationEl.style.display = 'none'; }, 2500);
        }

        async function playTurn() {
            if (state.isGameOver || state.isMoving) return;
            
            const player = currentPlayer();
            if (player.skippedTurns > 0) { 
                if (!isOnlineGame || auth.currentUser.uid === state.hostId) {
                    player.skippedTurns--; 
                    await sleep(1000); 
                    nextTurn(); 
                }
                return; 
            }
            
            const [d1, d2] = await rollDice();
            
            if (isOnlineGame) {
                await updateLobbySettings({ lastRoll: { uid: player.uid, d1, d2 }, diceResult: [d1,d2], isMoving: true });
            } else {
                state.isMoving = true;
                await handleMoveSequence(player, d1 + d2, false);
            }
        }
        
        async function rollDice() {
            diceContainer.classList.add('rolling');
            await sleep(1000);
            const d1 = Math.floor(Math.random() * 6) + 1, d2 = Math.floor(Math.random() * 6) + 1;
            dice1El.textContent = d1; dice2El.textContent = d2;
            diceContainer.classList.remove('rolling');
            return [d1, d2];
        }
        
        async function handleMoveSequence(player, steps, fromSpecial) {
            let currentPos = player.position;
            const direction = steps > 0 ? 1 : -1;
            for (let i = 0; i < Math.abs(steps); i++) {
                currentPos += direction;
                if (state.gameMode === 'elimination' || state.gameMode === 'gem') {
                    if (currentPos > state.totalTiles) { player.lap++; currentPos = 1; }
                    if (currentPos < 1) { player.lap = Math.max(1, player.lap - 1); currentPos = state.totalTiles; }
                } else {
                    if (currentPos > state.totalTiles) { currentPos = state.totalTiles - (currentPos - state.totalTiles); }
                    if (currentPos < 1) { currentPos = 1; }
                }
            }
            player.position = currentPos;

            if (checkGameOver()) { return; }
            
            if (fromSpecial) { nextTurn(); return; }
        
            const special = state.specialTiles[player.position];
            if (special) {
                showTileExplanation(special.type, special.gem?.name);
                await sleep(1500);
                switch(special.type) {
                    case 'goose': await handleMoveSequence(player, steps, true); break;
                    case 'forward 3': await handleMoveSequence(player, 3, true); break;
                    case 'backward 3': await handleMoveSequence(player, -3, true); break;
                    case 'forward 2': await handleMoveSequence(player, 2, true); break;
                    case 'backward 2': await handleMoveSequence(player, -2, true); break;
                    case 'death': await handleMoveSequence(player, -10, true); break;
                    case 'ponte': player.position = 12; await handleMoveSequence(player, 0, true); break;
                    case 'torre': player.position = 22; await handleMoveSequence(player, 0, true); break;
                    case 'maze': player.position = 39; await handleMoveSequence(player, 0, true); break;
                    case 'lose turns': player.skippedTurns = state.gameMode === 'elimination' ? 1 : 2; nextTurn(); break;
                    case 'prison': player.skippedTurns = state.gameMode === 'elimination' ? 1 : 3; nextTurn(); break;
                    case 'well': player.skippedTurns = 99; const wellPlayers = state.players.filter(p => p.skippedTurns === 99 && p.id !== player.id); if(wellPlayers.length > 0) wellPlayers.forEach(p => p.skippedTurns = 0); nextTurn(); break;
                    case 'swap':
                        const leadPlayer = state.players.filter(p => !p.isEliminated).sort((a,b) => (b.lap - a.lap) || (b.position - a.position))[0];
                        if (leadPlayer && leadPlayer.id !== player.id) { [player.position, leadPlayer.position] = [leadPlayer.position, player.position]; [player.lap, leadPlayer.lap] = [leadPlayer.lap, player.lap]; }
                        nextTurn(); break;
                    case 'swap random':
                        const otherPlayers = state.players.filter(p => !p.isEliminated && p.id !== player.id);
                        if (otherPlayers.length > 0) { const randomOpponent = otherPlayers[Math.floor(Math.random() * otherPlayers.length)]; [player.position, randomOpponent.position] = [randomOpponent.position, player.position]; [player.lap, randomOpponent.lap] = [randomOpponent.lap, player.lap]; }
                        nextTurn(); break;
                    case 'roll again':
                        if (isOnlineGame) { await updateLobbySettings({ players: state.players, lastRoll: null, isMoving: false }); }
                        else { state.isMoving = false; updateTurnIndicator(); }
                        break;
                    case 'gem':
                        if (!player.gems.includes(special.gem.id)) { player.gems.push(special.gem.id); }
                        nextTurn(); break;
                    case 'gem-thief':
                        if(player.gems.length > 0) { player.gems.splice(Math.floor(Math.random() * player.gems.length), 1); }
                        nextTurn(); break;
                    case 'gem-swap':
                        const opponentsWithGems = state.players.filter(p => p.id !== player.id && !p.isEliminated && p.gems.length > 0);
                        if(player.gems.length > 0 && opponentsWithGems.length > 0) {
                            const opponent = opponentsWithGems[Math.floor(Math.random() * opponentsWithGems.length)];
                            const playerGem = player.gems.splice(Math.floor(Math.random() * player.gems.length), 1)[0];
                            const opponentGem = opponent.gems.splice(Math.floor(Math.random() * opponent.gems.length), 1)[0];
                            player.gems.push(opponentGem);
                            opponent.gems.push(playerGem);
                        }
                        nextTurn(); break;
                     case 'gem-choice':
                        showGemChoiceModal(player);
                        break;
                    default: nextTurn(); break;
                }
            } else {
                nextTurn();
            }
        }
        
        function nextTurn() {
            const lastPlayerId = currentPlayer().id;
            const activePlayers = state.players.filter(p => !p.isEliminated);
            const lastActivePlayerInListId = activePlayers.length > 0 ? activePlayers[activePlayers.length - 1].id : -1;
            
            if (state.gameMode === 'elimination' && lastPlayerId === lastActivePlayerInListId) {
                state.gameRounds++;
                if (state.gameRounds > 0 && state.gameRounds % state.eliminationTurns === 0) {
                    eliminatePlayer();
                    if(checkGameOver()) return;
                }
            }

            do { state.currentPlayerIndex = (state.currentPlayerIndex + 1) % state.players.length; } while (currentPlayer().isEliminated);

            if (isOnlineGame) {
                updateLobbySettings({ players: state.players, currentPlayerIndex: state.currentPlayerIndex, gameRounds: state.gameRounds, isMoving: false, lastRoll: null });
            } else {
                 state.isMoving = false;
                 updateTurnIndicator();
                 updateTurnOrderIndicator();
                 if (state.gameMode === 'elimination') updateEliminationCounter();
                 if (currentPlayer().type === 'cpu') setTimeout(playTurn, 1500);
            }
        }

        function eliminatePlayer() {
            const activePlayers = state.players.filter(p => !p.isEliminated);
            if (activePlayers.length <= 1) return;
            activePlayers.sort((a,b) => (a.lap - b.lap) || (a.position - b.position));
            const playerToEliminate = activePlayers[0];
            playerToEliminate.isEliminated = true;
            eliminationMessageEl.textContent = `${playerToEliminate.name} è stato eliminato!`;
            eliminationMessageEl.style.display = 'block';
            setTimeout(() => { eliminationMessageEl.style.display = 'none'; }, 3000);
            const graveyardPawn = document.createElement('div');
            graveyardPawn.className = `graveyard-pawn ${colorClasses[playerToEliminate.color]}`;
            graveyardPawn.title = playerToEliminate.name;
            graveyardEl.appendChild(graveyardPawn);
        }

        function showGemChoiceModal(player) {
            const gemsForThisGame = gemList.slice(0, state.gemsToCollect);
            const missingGems = gemsForThisGame.filter(gem => !player.gems.includes(gem.id));
            gemChoiceOptions.innerHTML = '';

            if (missingGems.length === 0) {
                gemChoiceOptions.innerHTML = `<p class="text-gray-600">Hai già tutte le gemme!</p>`;
                setTimeout(() => { gemChoiceModal.style.display = 'none'; nextTurn(); }, 1500);
            } else {
                missingGems.forEach(gem => {
                    const gemDiv = document.createElement('div');
                    gemDiv.className = 'gem-choice-option flex items-center gap-2';
                    gemDiv.innerHTML = `<span class="text-3xl">${gem.icon}</span><span class="font-bold">${gem.name}</span>`;
                    gemDiv.onclick = () => {
                        player.gems.push(gem.id);
                        gemChoiceModal.style.display = 'none';
                        nextTurn();
                    };
                    gemChoiceOptions.appendChild(gemDiv);
                });
            }
            gemChoiceModal.style.display = 'flex';
        }

        function checkGameOver() {
            if (state.isGameOver) return true;
            let winner = null;
            if (state.gameMode === 'gem') {
                 const playerAtEnd = state.players.find(p => p.position >= state.totalTiles);
                 if (playerAtEnd) {
                     if (playerAtEnd.gems.length >= state.gemsToCollect) {
                         winner = playerAtEnd;
                     } else {
                         const gemsForThisGame = gemList.slice(0, state.gemsToCollect);
                         const missingGems = gemsForThisGame.filter(gem => !playerAtEnd.gems.includes(gem.id));
                         const closestMissingGemTile = Math.min(...missingGems.map(gem => state.gemLocations[gem.id]));
                         showTileExplanation('finish', 'ma ti mancano delle gemme! Torna indietro!');
                         playerAtEnd.position = closestMissingGemTile;
                     }
                 }
            }
            else if (state.gameMode === 'elimination') {
                const activePlayers = state.players.filter(p => !p.isEliminated);
                if (activePlayers.length === 1) winner = activePlayers[0];
            } else if (state.gameMode === 'teams') {
                const teams = {};
                state.players.forEach(p => { if (!teams[p.team]) teams[p.team] = []; teams[p.team].push(p); });
                for (const teamId in teams) { if (teams[teamId].every(p => p.position >= state.totalTiles)) { winner = { name: `Squadra ${teamId}`, isTeam: true }; } }
            } else { winner = state.players.find(p => p.position >= state.totalTiles); }
            if (winner) {
                state.isGameOver = true;
                if(isOnlineGame) updateLobbySettings({ isGameOver: true, status: 'finished', players: state.players });
                showPodium();
                return true;
            }
            return false;
        }

        function showPodium() {
            const sortedPlayers = [...state.players].sort((a, b) => { if(a.isEliminated && !b.isEliminated) return 1; if(!a.isEliminated && b.isEliminated) return -1; return (b.lap - a.lap) || (b.position - a.position); });
            const podiumSpots = ['1', '2', '3'];
            podiumSpots.forEach(rank => {
                const player = sortedPlayers[rank-1];
                const podiumEl = document.getElementById(`podium-${rank}`);
                const pawnEl = document.getElementById(`pawn-${rank}`);
                const nameEl = document.getElementById(`name-${rank}`);
                if (player) {
                    pawnEl.className = `w-12 h-12 rounded-full border-4 border-white mb-2 ${colorClasses[player.color]}`;
                    nameEl.textContent = player.name;
                    podiumEl.style.display = 'flex';
                } else {
                    podiumEl.style.display = 'none';
                }
            });
            podiumModal.style.display = 'flex';
        }

        function setupRulesModals() {
            classicRulesEl.innerHTML = `
                <h3 class="text-xl font-bold mb-2">Modalità Classica / Eliminazione / Squadre</h3>
                <ul class="space-y-1 text-sm md:text-base">
                    <li><strong class="text-green-600">Oca (9x):</strong> Ripeti il movimento del tuo ultimo lancio.</li>
                    <li><strong class="text-yellow-800">Ponte (1x):</strong> Vai subito alla casella 12.</li>
                    <li><strong class="text-gray-500">Torre (1x):</strong> Vai subito alla casella 22.</li>
                    <li><strong class="text-blue-600">Pozzo (2x):</strong> Fermo finché un altro giocatore non arriva qui. (Non in modalità Eliminazione)</li>
                    <li><strong class="text-purple-600">Labirinto (2x):</strong> Torna alla casella 39.</li>
                    <li><strong class="text-gray-700">Prigione (4x):</strong> Stai fermo per 3 turni (1 in modalità Eliminazione).</li>
                    <li><strong class="text-black">Teschio (3x):</strong> Torna indietro di 10 caselle.</li>
                    <li><strong class="text-orange-500">Stop (5x):</strong> Stai fermo per 2 turni (1 in modalità Eliminazione).</li>
                    <li><strong class="text-cyan-500">Scambia (2x):</strong> Scambia posizione con il primo in classifica.</li>
                    <li><strong class="text-pink-500">Scambia? (2x):</strong> Scambia posizione con un giocatore a caso.</li>
                </ul>`;
            gemRulesEl.innerHTML = `
                <h3 class="text-xl font-bold mb-2">Modalità Oca da Collezione</h3>
                <p class="mb-2">L'obiettivo è raccogliere tutte le gemme e raggiungere l'ultima casella. Se arrivi alla fine senza tutte le gemme, verrai respinto!</p>
                <ul class="space-y-1 text-sm md:text-base">
                    <li><strong>Casella Gemma (2x per tipo):</strong> Raccogli la gemma indicata.</li>
                    <li><strong class="text-purple-700">Ladro di Gemme (1x):</strong> Perdi una gemma a caso!</li>
                    <li><strong class="text-cyan-700">Baratto di Gemme (1x):</strong> Scambi una tua gemma a caso con quella di un avversario.</li>
                    <li><strong class="text-yellow-500">Santuario (1x):</strong> Scegli una gemma mancante e ottienila!</li>
                </ul>`;
        }
        
        rulesBtn.addEventListener('click', () => {
            const currentMode = gameModeSelect.value;
            classicRulesEl.style.display = (currentMode !== 'gem') ? 'block' : 'none';
            gemRulesEl.style.display = (currentMode === 'gem') ? 'block' : 'none';
            rulesModal.style.display = 'flex'
        });

        diceContainer.addEventListener('click', () => {
            const player = currentPlayer();
            if(!player || player.type !== 'human' || state.isMoving) return;

            if (isOnlineGame) {
                const user = auth.currentUser;
                if (user && player.uid === user.uid) {
                    playTurn();
                }
            } else {
                playTurn();
            }
        });

        menuButton.addEventListener('click', () => menuModal.style.display = 'flex');
        closeMenuBtn.addEventListener('click', () => menuModal.style.display = 'none');
        returnToMenuBtn.addEventListener('click', () => { 
            const confirmationText = isOnlineGame ? 'Uscire dalla partita online?' : 'Tornare al menu? La partita andrà persa.';
            showConfirmation(confirmationText, () => {
                if (isOnlineGame) {
                    leaveLobbyBtn.click();
                } else {
                    location.reload();
                }
            }); 
        });
        playAgainBtn.addEventListener('click', () => resetToMainMenu());
        podiumPlayAgainBtn.addEventListener('click', () => resetToMainMenu());
        closeRulesBtn.addEventListener('click', () => rulesModal.style.display = 'none');
        copyCodeBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(currentLobbyId).then(() => {
                copyCodeBtn.textContent = 'Copiato!';
                setTimeout(() => copyCodeBtn.textContent = 'Copia', 1500);
            });
        });

        function showConfirmation(text, onConfirm) {
             document.getElementById('confirm-text').textContent = text;
             confirmModal.style.display = 'flex';
             confirmYesBtn.onclick = () => { confirmModal.style.display = 'none'; onConfirm(); };
             confirmNoBtn.onclick = () => { confirmModal.style.display = 'none'; };
        }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    }
    </script>
</body>
</html>
